-- 
-- Script was generated by Devart dbForge Schema Compare for SQL Server, Version 4.5.90.0
-- Product Home Page: http://www.devart.com/dbforge/sql/schemacompare/
-- Script date 18-10-19 20:13:39
-- Server version: 14.00.3048
-- Run this script against EmaintenanceUAT to synchronize it with EmaintenancePROD
-- 
 
--
-- Set transaction isolation level
--
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO

--
-- Start Transaction
--
BEGIN TRANSACTION
GO

--
-- Alter procedure [dbo].[EAppDBContractPerformanceStatistics]
--
GO
 
CREATE OR ALTER PROCEDURE [dbo].[EAppDBContractPerformanceStatistics]
	 @UserId Int  
WITH ENCRYPTION
AS
BEGIN
  
 	select  r.ClientSiteId,r.ClientSiteName,r.PlantAreaId, Concat(r.PlantAreaName,'-',r.PlantAreaId)PlantAreaName, r.RDate,r.RType,r.RName,r.RValue 
 	from [RptContractPerformance] r join (select   ClientSiteId from dbo.udtfClientAccess(@UserId)) c on c.ClientSiteId = r.ClientSiteId
 	where RDate >= DATEADD(year,-1,getdate())
	order by ClientSiteId,RType  
 
End
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop column [SysRemarks] from table [dbo].[JobEquipUnitSymptoms]
--
ALTER TABLE [dbo].[JobEquipUnitSymptoms]
  DROP COLUMN IF EXISTS [SysRemarks]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Refresh view [dbo].[SS_MonitoringAlarm]
--
EXEC sp_refreshview '[dbo].[SS_MonitoringAlarm]'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [dbo].[EAppSaveJobUnitAnalysis]
--
GO
CREATE OR ALTER PROCEDURE [dbo].[EAppSaveJobUnitAnalysis]
	 @UnitAnalysisId Bigint 
	,@JobEquipmentId Bigint 
	,@ServiceId int    
	,@UnitType  varchar(3) 
	,@UnitId Bigint 
	,@ConditionId Int
	,@ConfidentFactorId int
	,@FailureProbFactorId Int
	,@PriorityId int
	,@IsWorkNotification Varchar(1)
	,@NoOfDays Decimal(4,2)
	,@Recommendation nVarchar(1500)
	,@Comment nVarchar(2500)
    ,@UnitSymptomsJson nvarchar(max)
	,@UnitAmplitudeJson nvarchar(max)
	,@StatusId int
	,@UserId int
	,@IsEC varchar(1) 
	,@Result Varchar(1) OUTPUT
	,@ResultText nvarchar(2500) OUTPUT
WITH ENCRYPTION
AS
BEGIN
 	BEGIN TRANSACTION
	BEGIN TRY
		Declare @OldStatusid int, @UpdateEquipStatusid int, @WNConditionCheck int , @WNPriorityCheck varchar(30), @NStatusId int
  		DECLARE @Created TABLE (
			[UnitAnalysisId] Bigint
			,PRIMARY KEY ([UnitAnalysisId])
			);
		set @UpdateEquipStatusid =dbo.GetStatusId(1,'JobProcessStatus','IP');;
		Set @OldStatusid = 0;

		select @WNConditionCheck =  cast(isnull(dbo.GetLookupTranslated(@ConditionId,1,'LookupCode'),0) as int) 
			,@WNPriorityCheck =  isnull(dbo.GetLookupTranslated(@PriorityId,1,'LookupCode'),'')
		select  @IsWorkNotification = case when (isnull(@WNConditionCheck,0) > 1 and isnull(@WNPriorityCheck,'') in ('DPIA','DPRC')) then 'Y' else 'N' end
 
 
  		MERGE [dbo].[JobEquipUnitAnalysis] AS [target] 
		USING (
			SELECT @UnitAnalysisId 
			) AS source(UnitAnalysisId)
			ON ([target].[UnitAnalysisId] = [source].[UnitAnalysisId])
		WHEN MATCHED
			THEN 
				UPDATE 
				SET    
				JobEquipmentId = @JobEquipmentId  
				,ServiceId = @ServiceId 
				,UnitType = @UnitType
				,UnitId = @UnitId 
				,ConditionId = @ConditionId 
				,ConfidentFactorId = @ConfidentFactorId 
				,FailureProbFactorId = @FailureProbFactorId 
				,PriorityId = @PriorityId 
				,IsWorkNotification = @IsWorkNotification 
				,NoOfDays = @NoOfDays 
				,Recommendation = @Recommendation 
				,Comment = @Comment 
				,StatusId = @StatusId 
			 WHEN NOT MATCHED BY TARGET
			THEN
				INSERT ( 
				JobEquipmentId 
				,ServiceId 
				,UnitType  
				,UnitId 
				,ConditionId 
				,ConfidentFactorId 
				,FailureProbFactorId  
				,PriorityId 
				,IsWorkNotification 
				,NoOfDays  
				,Recommendation 
				,Comment 
				,StatusId
				,CreatedBy
					)
				VALUES ( 
				@JobEquipmentId  
				,@ServiceId 
				,@UnitType 
				,@UnitId 
				,@ConditionId 
				,@ConfidentFactorId 
				,@FailureProbFactorId 
				,@PriorityId 
				,@IsWorkNotification 
				,@NoOfDays 
				,@Recommendation 
				,@Comment 
				,@StatusId
				,@UserId 
				) OUTPUT INSERTED.UnitAnalysisId
				INTO @Created ;
			    
				SELECT @UnitAnalysisId = [UnitAnalysisId]
				FROM @Created; 

				if  isnull(@UnitAnalysisId,0) > 0
				Begin
					Declare @JobId Bigint
					Update JobEquipment set StatusId =	@UpdateEquipStatusid where JobEquipmentId = @JobEquipmentId 
					Select @JobId = JobId from JobEquipment where JobEquipmentId = @JobEquipmentId
					Update Jobs set StatusId =@UpdateEquipStatusid where Jobid = @JobId
				End
				
 ---- Process Start Unit Systems ------
	DECLARE @UnitSymptomsId Bigint, @SymptomTypeId int, @FrequencyId int, @FailureModeId Int, @IndicatedFaultId int, @Symptoms nvarchar (1500), @Active Varchar(1)
	
	DROP TABLE IF EXISTS #LoadUnitSymptomsJson

	CREATE TABLE #LoadUnitSymptomsJson
	(
	  LoaderId int not null identity(1,1),
      UnitSymptomsId Bigint, 
      UnitAnalysisId Bigint, 
      SymptomTypeId int, 
      FrequencyId int,
	  FailureModeId int,
      IndicatedFaultId int,
      Symptoms nvarchar (1500),
      Active Varchar(1)
	) 
	 
Insert into #LoadUnitSymptomsJson (UnitSymptomsId,UnitAnalysisId,SymptomTypeId,FrequencyId, FailureModeId ,IndicatedFaultId,Symptoms,Active)
SELECT
    JSON_Value (c.value, '$.UnitSymptomsId') as UnitSymptomsId, 
	JSON_Value (c.value, '$.UnitAnalysisId') as UnitAnalysisId,
	JSON_Value (c.value, '$.SymptomTypeId') as SymptomTypeId,
	JSON_Value (c.value, '$.FrequencyId') as FrequencyId,
	JSON_Value (c.value, '$.FailureModeId') as FailureModeId,
	JSON_Value (c.value, '$.IndicatedFaultId') as IndicatedFaultId,
	JSON_Value (c.value, '$.Symptoms') as Symptoms,
	JSON_Value (c.value, '$.Active') as Active
FROM OPENJSON ( @UnitSymptomsJson , '$.JobUnitSymptomsList') as c 
  
DECLARE GetJobUnitSymptomsCur CURSOR READ_ONLY
    FOR
    SELECT UnitSymptomsId,SymptomTypeId,FrequencyId, case when FailureModeId = 0 then null else FailureModeId end FailureModeId ,case when IndicatedFaultId = 0 then null else IndicatedFaultId end IndicatedFaultId,Symptoms,Active
	from #LoadUnitSymptomsJson  

    OPEN GetJobUnitSymptomsCur
    FETCH NEXT FROM GetJobUnitSymptomsCur INTO
    @UnitSymptomsId,@SymptomTypeId,@FrequencyId, @FailureModeId ,@IndicatedFaultId,@Symptoms,@Active 
    WHILE @@FETCH_STATUS = 0
		BEGIN 
		 	MERGE [dbo].[JobEquipUnitSymptoms] AS [target]
			USING (
				SELECT @UnitSymptomsId
				) AS source(UnitSymptomsId)
				ON ([target].[UnitSymptomsId] = [source].[UnitSymptomsId])
			WHEN MATCHED THEN
				UPDATE SET  
						 SymptomTypeId = @SymptomTypeId
						 ,FrequencyId = @FrequencyId
						 ,FailureModeId = @FailureModeId
						 ,IndicatedFaultId = @IndicatedFaultId
						 ,Symptoms = @Symptoms
						 ,Active = @Active 
 			WHEN NOT MATCHED BY TARGET
					THEN
						INSERT (  
						 UnitAnalysisId,
						 SymptomTypeId,
						 FrequencyId,
						 FailureModeId,
						 IndicatedFaultId,
						 Symptoms,
						 Active, 
						 CreatedBy
							)
						VALUES (  
						  @UnitAnalysisId
						 ,@SymptomTypeId
						 ,@FrequencyId
						 ,@FailureModeId
						 ,@IndicatedFaultId
						 ,@Symptoms
						 ,@Active 
						 ,@UserId
							)
						;
		FETCH NEXT FROM GetJobUnitSymptomsCur INTO @UnitSymptomsId,@SymptomTypeId,@FrequencyId, @FailureModeId ,@IndicatedFaultId,@Symptoms,@Active
		END
    CLOSE GetJobUnitSymptomsCur
    DEALLOCATE GetJobUnitSymptomsCur
 ---- Process End UnitAnalysis ------
 
 ---- Process Amplitude start------
 
 	DECLARE @UnitAmplitudeId Bigint, @OAVibration nvarchar(250), @OAGELevelPkPk nvarchar(250), @OASensorDirection int, @OASensorLocation int,@OAVibChangePercentage int, @AActive Varchar(1)
	
	DROP TABLE IF EXISTS #LoadUnitAmplitudeJson

	CREATE TABLE #LoadUnitAmplitudeJson
	(
	  LoaderId int not null identity(1,1),
      UnitAmplitudeId Bigint, 
      UnitAnalysisId Bigint, 
      OAVibration nvarchar(250),
	  OAGELevelPkPk nvarchar(250), 
	  OASensorDirection int,
	  OASensorLocation int,
	  OAVibChangePercentage int,
      Active Varchar(1)
	) 
	 
Insert into #LoadUnitAmplitudeJson (UnitAmplitudeId,UnitAnalysisId,OAVibration,OAGELevelPkPk,OASensorDirection,OASensorLocation,OAVibChangePercentage,Active)
SELECT
    JSON_Value (c.value, '$.UnitAmplitudeId') as UnitAmplitudeId, 
	JSON_Value (c.value, '$.UnitAnalysisId') as UnitAnalysisId,
	JSON_Value (c.value, '$.OAVibration') as OAVibration,
	JSON_Value (c.value, '$.OAGELevelPkPk') as OAGELevelPkPk,
	JSON_Value (c.value, '$.OASensorDirection') as OASensorDirection,
	JSON_Value (c.value, '$.OASensorLocation') as OASensorLocation,
	JSON_Value (c.value, '$.OAVibChangePercentage') as OAVibChangePercentage,
	JSON_Value (c.value, '$.Active') as Active
FROM OPENJSON ( @UnitAmplitudeJson , '$.JobUnitAmplitudeList') as c 
  
DECLARE GetJobUnitAmplitudeCur CURSOR READ_ONLY
    FOR
    SELECT UnitAmplitudeId,OAVibration,OAGELevelPkPk,OASensorDirection,OASensorLocation,OAVibChangePercentage,Active
	from #LoadUnitAmplitudeJson  

    OPEN GetJobUnitAmplitudeCur
    FETCH NEXT FROM GetJobUnitAmplitudeCur INTO
    @UnitAmplitudeId,@OAVibration,@OAGELevelPkPk,@OASensorDirection,@OASensorLocation,@OAVibChangePercentage,@AActive
    WHILE @@FETCH_STATUS = 0
		BEGIN
		 	MERGE [dbo].[JobEquipUnitAmplitude] AS [target]
			USING (
				SELECT @UnitAmplitudeId
				) AS source(UnitAmplitudeId)
				ON ([target].[UnitAmplitudeId] = [source].[UnitAmplitudeId])
			WHEN MATCHED THEN
				UPDATE SET
						 OAVibration = @OAVibration
						 ,OAGELevelPkPk = @OAGELevelPkPk
						 ,OASensorDirection = @OASensorDirection
						 ,OASensorLocation = @OASensorLocation
						 ,OAVibChangePercentage = @OAVibChangePercentage
						 ,Active = @Active 
 			WHEN NOT MATCHED BY TARGET
					THEN
						INSERT (  
 						 UnitAnalysisId,
						 OAVibration,
						 OAGELevelPkPk,
						 OASensorDirection,
						 OASensorLocation,
						 OAVibChangePercentage,
						 Active, 
						 CreatedBy
							)
						VALUES (  
						  @UnitAnalysisId
						 ,@OAVibration
						 ,@OAGELevelPkPk
						 ,@OASensorDirection
						 ,@OASensorLocation
						 ,@OAVibChangePercentage
						 ,@Active 
						 ,@UserId
						 )
						;
		FETCH NEXT FROM GetJobUnitAmplitudeCur INTO @UnitAmplitudeId,@OAVibration,@OAGELevelPkPk,@OASensorDirection,@OASensorLocation,@OAVibChangePercentage,@AActive
		END
    CLOSE GetJobUnitAmplitudeCur
    DEALLOCATE GetJobUnitAmplitudeCur
 ---- Process Amplitude End------
  	EXEC [dbo].[EAppECJobEquipUnitAnalysis]	 @UnitAnalysisId,@StatusId,@UserId,@NStatusId = @NStatusId OUTPUT,@Result = @Result OUTPUT, @ResultText = @ResultText OUTPUT
 	if @Result in('E', 'S')
	Begin
		Update JobEquipUnitAnalysis set DataValidationStatus = case when @Result = 'S' then 1 when @Result = 'E' then 2 end,
		DataValidationText = case when @Result = 'E' then @ResultText else '' end 
		where UnitAnalysisId = @UnitAnalysisId;
	End
	
 		Declare @ECCode int  
		select top 1 @ECCode = l.LookupId from lookups l join JobEquipUnitAnalysis ju on ju.ConditionId = l.LookupId
		where ju.JobEquipmentId = @JobEquipmentId order by l.lookupcode desc 
		if isnull(@ECCode,0) <> 0
		Begin---Job Equipment Auto Condition Update.
			Update JobEquipment set ConditionId = @ECCode where JobEquipmentId = @JobEquipmentId;
		End 
	COMMIT TRANSACTION 
	SELECT UnitAnalysisId as UnitAnalysisId FROM @Created;

	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRANSACTION;
		THROW;
	END CATCH
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [dbo].[EAppSaveJobEquipUnitSelected]
--
GO

CREATE OR ALTER PROCEDURE [dbo].[EAppSaveJobEquipUnitSelected] 
	 @JobEquipmentId Bigint 
	,@ServiceId int    
	,@UnitType  varchar(3) 
	,@UnitId Bigint  
	,@StatusId int
	,@UserId int
	,@LanguageId int 
WITH ENCRYPTION
AS
BEGIN
 	BEGIN TRANSACTION
	BEGIN TRY
	Declare @UnitAnalysisId Bigint, @UnitAmplitudeJson nvarchar(max) , @UnitSymptomsJson nvarchar(max) 
	Set @UnitAnalysisId = 0
 	Select  @StatusId = dbo.GetStatusId(1,'JobProcessStatus','NS');
   		DECLARE @Created TABLE (
			[UnitAnalysisId] Bigint
			,PRIMARY KEY ([UnitAnalysisId])
			);
 
  		MERGE [dbo].[JobEquipUnitAnalysis] AS [target] 
		USING (
			SELECT @UnitAnalysisId 
			) AS source(UnitAnalysisId)
			ON ([target].[UnitAnalysisId] = [source].[UnitAnalysisId])
 			 WHEN NOT MATCHED BY TARGET
			THEN
				INSERT ( 
				JobEquipmentId 
				,ServiceId 
				,UnitType  
				,UnitId  
				,StatusId
				,CreatedBy
					)
				VALUES ( 
				 @JobEquipmentId  
				,@ServiceId 
				,@UnitType 
				,@UnitId  
				,@StatusId
				,@UserId 
				) OUTPUT INSERTED.UnitAnalysisId
				INTO @Created ;
			    
				SELECT @UnitAnalysisId = [UnitAnalysisId]
				FROM @Created; 
---- Process Start Unit Systems ------
	DECLARE @ServiceType varchar(3) , @UnitSymptomsId Bigint, @SymptomTypeId int, @FrequencyId int, @FailureModeId Int, @IndicatedFaultId int, @Symptoms nvarchar (1500), @Active Varchar(1)
	
	Declare @SymptomsTemplate Table(SymptomJsonTemplate nvarchar(max))
	Set @ServiceType = isnull(dbo.GetLookupTranslated(@ServiceId, @LanguageId,'LookupCode'),'')
	
	Insert into @SymptomsTemplate(SymptomJsonTemplate)
	Exec [EAppGetUnitSymptomsTemplate] @UnitType,@ServiceType,@LanguageId
	Select @UnitSymptomsJson = SymptomJsonTemplate from @SymptomsTemplate

	DROP TABLE IF EXISTS #LoadUnitSymptomsJson
	
	CREATE TABLE #LoadUnitSymptomsJson
	(
	  LoaderId int not null identity(1,1),
      UnitSymptomsId Bigint, 
      UnitAnalysisId Bigint, 
      SymptomTypeId int, 
      FrequencyId int,
	  FailureModeId int,
      IndicatedFaultId int,
      Symptoms nvarchar (1500),
      Active Varchar(1)
	) 
	 
Insert into #LoadUnitSymptomsJson (UnitSymptomsId,UnitAnalysisId,SymptomTypeId,FrequencyId, FailureModeId ,IndicatedFaultId,Symptoms,Active)
SELECT
    JSON_Value (c.value, '$.UnitSymptomsId') as UnitSymptomsId, 
	JSON_Value (c.value, '$.UnitAnalysisId') as UnitAnalysisId,
	JSON_Value (c.value, '$.SymptomTypeId') as SymptomTypeId,
	JSON_Value (c.value, '$.FrequencyId') as FrequencyId,
	JSON_Value (c.value, '$.FailureModeId') as FailureModeId,
	JSON_Value (c.value, '$.IndicatedFaultId') as IndicatedFaultId,
	JSON_Value (c.value, '$.Symptoms') as Symptoms,
	JSON_Value (c.value, '$.Active') as Active
FROM OPENJSON ( @UnitSymptomsJson) as c 
  
DECLARE GetJobUnitSymptomsCur CURSOR READ_ONLY
    FOR
    SELECT UnitSymptomsId,SymptomTypeId,FrequencyId, case when FailureModeId = 0 then null else FailureModeId end FailureModeId ,case when IndicatedFaultId = 0 then null else IndicatedFaultId end IndicatedFaultId,Symptoms,Active
	from #LoadUnitSymptomsJson  

    OPEN GetJobUnitSymptomsCur
    FETCH NEXT FROM GetJobUnitSymptomsCur INTO
    @UnitSymptomsId,@SymptomTypeId,@FrequencyId, @FailureModeId ,@IndicatedFaultId,@Symptoms,@Active 
    WHILE @@FETCH_STATUS = 0
		BEGIN 
		 	MERGE [dbo].[JobEquipUnitSymptoms] AS [target]
			USING (
				SELECT @UnitSymptomsId
				) AS source(UnitSymptomsId)
				ON ([target].[UnitSymptomsId] = [source].[UnitSymptomsId])
 			WHEN NOT MATCHED BY TARGET
					THEN
						INSERT (  
						 UnitAnalysisId,
						 SymptomTypeId,
						 FrequencyId,
						 FailureModeId,
						 IndicatedFaultId,
						 Symptoms,
						 Active, 
						 CreatedBy
							)
						VALUES (  
						  @UnitAnalysisId
						 ,@SymptomTypeId
						 ,@FrequencyId
						 ,@FailureModeId
						 ,@IndicatedFaultId
						 ,@Symptoms
						 ,@Active 
						 ,@UserId
							)
						;
		FETCH NEXT FROM GetJobUnitSymptomsCur INTO @UnitSymptomsId,@SymptomTypeId,@FrequencyId, @FailureModeId ,@IndicatedFaultId,@Symptoms,@Active
		END
    CLOSE GetJobUnitSymptomsCur
    DEALLOCATE GetJobUnitSymptomsCur
 ---- Process End UnitAnalysis ------
 
 ---- Process Amplitude start------
 
 	DECLARE @UnitAmplitudeId Bigint, @OAVibration nvarchar(250), @OAGELevelPkPk nvarchar(250), @OASensorDirection int, @OASensorLocation int,@OAVibChangePercentage int, @AActive Varchar(1)
	set @UnitAmplitudeJson = '[{
                    "UnitAmplitudeId": 0,
                    "UnitAnalysisId": 0,
                    "OAVibration": null,
                    "OAGELevelPkPk": null,
                    "OASensorDirection": null,
                    "OASensorLocation": null,
                    "OAVibChangePercentage": null,
                    "Active": "Y"
                },
                {
                    "UnitAmplitudeId": 0,
                    "UnitAnalysisId": 0,
                    "OAVibration": null,
                    "OAGELevelPkPk": null,
                    "OASensorDirection": null,
                    "OASensorLocation": null,
                    "OAVibChangePercentage": null,
                    "Active": "Y"
                },
                {
                    "UnitAmplitudeId": 0,
                    "UnitAnalysisId": 0,
                    "OAVibration": null,
                    "OAGELevelPkPk": null,
                    "OASensorDirection": null,
                    "OASensorLocation": null,
                    "OAVibChangePercentage": null,
                    "Active": "Y"
                }]'
	DROP TABLE IF EXISTS #LoadUnitAmplitudeJson

	CREATE TABLE #LoadUnitAmplitudeJson
	(
	  LoaderId int not null identity(1,1),
      UnitAmplitudeId Bigint, 
      UnitAnalysisId Bigint, 
      OAVibration nvarchar(250),
	  OAGELevelPkPk nvarchar(250), 
	  OASensorDirection int,
	  OASensorLocation int,
	  OAVibChangePercentage int,
      Active Varchar(1)
	) 
	 
Insert into #LoadUnitAmplitudeJson (UnitAmplitudeId,UnitAnalysisId,OAVibration,OAGELevelPkPk,OASensorDirection,OASensorLocation,OAVibChangePercentage,Active)
SELECT
    JSON_Value (c.value, '$.UnitAmplitudeId') as UnitAmplitudeId, 
	JSON_Value (c.value, '$.UnitAnalysisId') as UnitAnalysisId,
	JSON_Value (c.value, '$.OAVibration') as OAVibration,
	JSON_Value (c.value, '$.OAGELevelPkPk') as OAGELevelPkPk,
	JSON_Value (c.value, '$.OASensorDirection') as OASensorDirection,
	JSON_Value (c.value, '$.OASensorLocation') as OASensorLocation,
	JSON_Value (c.value, '$.OAVibChangePercentage') as OAVibChangePercentage,
	JSON_Value (c.value, '$.Active') as Active
FROM OPENJSON ( @UnitAmplitudeJson  ) as c 
  
DECLARE GetJobUnitAmplitudeCur CURSOR READ_ONLY
    FOR
    SELECT UnitAmplitudeId,OAVibration,OAGELevelPkPk,OASensorDirection,OASensorLocation,OAVibChangePercentage,Active
	from #LoadUnitAmplitudeJson  

    OPEN GetJobUnitAmplitudeCur
    FETCH NEXT FROM GetJobUnitAmplitudeCur INTO
    @UnitAmplitudeId,@OAVibration,@OAGELevelPkPk,@OASensorDirection,@OASensorLocation,@OAVibChangePercentage,@AActive
    WHILE @@FETCH_STATUS = 0
		BEGIN
		 	MERGE [dbo].[JobEquipUnitAmplitude] AS [target]
			USING (
				SELECT @UnitAmplitudeId
				) AS source(UnitAmplitudeId)
				ON ([target].[UnitAmplitudeId] = [source].[UnitAmplitudeId])
			WHEN MATCHED THEN
				UPDATE SET
						 OAVibration = @OAVibration
						 ,OAGELevelPkPk = @OAGELevelPkPk
						 ,OASensorDirection = @OASensorDirection
						 ,OASensorLocation = @OASensorLocation
						 ,OAVibChangePercentage = @OAVibChangePercentage
						 ,Active = @Active 
 			WHEN NOT MATCHED BY TARGET
					THEN
						INSERT (  
 						 UnitAnalysisId,
						 OAVibration,
						 OAGELevelPkPk,
						 OASensorDirection,
						 OASensorLocation,
						 OAVibChangePercentage,
						 Active, 
						 CreatedBy
							)
						VALUES (  
						  @UnitAnalysisId
						 ,@OAVibration
						 ,@OAGELevelPkPk
						 ,@OASensorDirection
						 ,@OASensorLocation
						 ,@OAVibChangePercentage
						 ,@Active 
						 ,@UserId
						 )
						;
		FETCH NEXT FROM GetJobUnitAmplitudeCur INTO @UnitAmplitudeId,@OAVibration,@OAGELevelPkPk,@OASensorDirection,@OASensorLocation,@OAVibChangePercentage,@AActive
		END
    CLOSE GetJobUnitAmplitudeCur
    DEALLOCATE GetJobUnitAmplitudeCur
	COMMIT TRANSACTION 
		 
	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK TRANSACTION;
		THROW;
	END CATCH
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [dbo].[EAppListJobUnitAnalysis]
--
GO
 
CREATE OR ALTER PROCEDURE [dbo].[EAppListJobUnitAnalysis]
	 @UnitAnalysisId Bigint
	 ,@UnitType Varchar(3) 
	 ,@ServiceType varchar(3)
	,@LanguageId int 
WITH ENCRYPTION
AS
BEGIN
	Declare @SymtomName varchar(30),@FrequencyName varchar(30)

	select @FrequencyName =case when @ServiceType = 'OA' then 'JobFrequencyOA' else 'JobFrequency' End ,
	 @SymtomName = case when @ServiceType = 'OA' then 'JobSymptomTypeOA' when (@UnitType = 'DR' and @ServiceType = 'VA') then 'JobSymptomType' when (@UnitType = 'DN' and @ServiceType = 'VA') then 'JobSymptomType' when (@UnitType = 'IN' and @ServiceType = 'VA') then 'JobSymptomTypeShaft' End ;
 
 	DECLARE @SymptomsLookup TABLE (
	[SymptomTypeId] int,
	[FrequencyId] int,
	[SListOrder] int,
	[FListOrder] int 
	);
	
 
	Insert into @SymptomsLookup(FrequencyId,FListOrder,SymptomTypeId,SListOrder)
	select a.lookupid as 'FrequencyId',a.ListOrder ,b.lookupid  as 'SymptomTypeId',b.ListOrder 
	from lookups a cross join lookups b where a.lname = @FrequencyName and b.lname = @SymtomName

 	Select u.UnitAnalysisId,u.JobEquipmentId,u.ServiceId,u.UnitType,u.UnitId, u.ConditionId,u.ConfidentFactorId,u.FailureProbFactorId,u.PriorityId,u.IsWorkNotification,u.NoOfDays,u.Recommendation,u.Comment,u.StatusId,
	(select isnull(js.UnitSymptomsId ,0) as UnitSymptomsId,isnull(js.UnitAnalysisId ,0) as UnitAnalysisId,
	isnull(js.SymptomTypeId,sl.SymptomTypeId) as SymptomTypeId,  
	dbo.GetLookupTranslated(js.SymptomTypeId, @LanguageId,'LookupValue')as SymptomType,
	isnull(js.FrequencyId,sl.FrequencyId) as FrequencyId,   
	dbo.GetLookupTranslated(js.FrequencyId, @LanguageId,'LookupValue')as Frequency,
	js.FailureModeId as FailureModeId,js.IndicatedFaultId as IndicatedFaultId,  
	js.Symptoms as Symptoms,isnull(js.Active,'N') as Active
	from JobEquipUnitSymptoms js Right Join @SymptomsLookup sl on (sl.SymptomTypeId = js.SymptomTypeId and sl.FrequencyId = js.FrequencyId)   
	and js.UnitAnalysisId = u.UnitAnalysisId		
	order by sl.SListOrder,sl.FListOrder				  
	FOR JSON AUTO , INCLUDE_NULL_VALUES
	) JobUnitSymptomsListJson,
	(select isnull(ja.UnitAmplitudeId ,0) as UnitAmplitudeId, ja.UnitAnalysisId   as UnitAnalysisId,
	ja.OAVibration  as OAVibration,
	ja.OAGELevelPkPk  as OAGELevelPkPk, ja.OASensorDirection as OASensorDirection,
	ja.OASensorLocation  as OASensorLocation, ja.OAVibChangePercentage  as OAVibChangePercentage,
	isnull(ja.Active,'N') as Active
	from JobEquipUnitAmplitude ja where ja.UnitAnalysisId = u.UnitAnalysisId 
	FOR JSON AUTO  , INCLUDE_NULL_VALUES
	) JobUnitAmplitudeListJson
	from JobEquipUnitAnalysis u  where u.UnitAnalysisId = @UnitAnalysisId
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [dbo].[EAppListJobEquipUnitAnalysis]
--
GO
CREATE OR ALTER PROCEDURE [dbo].[EAppListJobEquipUnitAnalysis] 
	@JobEquipmentId Bigint, 
	@LanguageId int,
	@StatusId int
WITH ENCRYPTION
AS
BEGIN  
 
 Declare @JobId Bigint, @EquipmentId Int, @NewStatus int,@DataCollectionDone int, @WNOpenStatusId int

 select  @JobId = JobId, @EquipmentId = EquipmentId, @NewStatus = dbo.GetStatusId(1,'JobProcessStatus','NS'),@WNOpenStatusId = dbo.GetStatusId(1,'WorkNotificationStatus','OP'),
 @DataCollectionDone = DataCollectionDone
 from JobEquipment where JobEquipmentId = @JobEquipmentId
 
	select UnitAnalysisId, JobEquipmentId,@JobId as JobId,@EquipmentId as EquipmentId,
	isnull(dbo.GetNameTranslated(@EquipmentId,@LanguageId,'EquipmentName'),'') as EquipmentName,
	UnitType,UnitId, 
		Case when UnitType = 'DR' then (select AssetId from EquipmentDriveUnit where DriveUnitId = UnitId) 
		 when UnitType = 'IN' then (select AssetId from EquipmentIntermediateUnit where IntermediateUnitId = UnitId)
		 when UnitType = 'DN' then (select AssetId from EquipmentDrivenUnit where DrivenUnitId = UnitId) 
		 end AssetId, 
		Case when UnitType = 'DR' then (select IdentificationName from EquipmentDriveUnit where DriveUnitId = UnitId) 
		 when UnitType = 'IN' then (select IdentificationName from EquipmentIntermediateUnit where IntermediateUnitId = UnitId)
		 when UnitType = 'DN' then (select IdentificationName from EquipmentDrivenUnit where DrivenUnitId = UnitId) 
		 end  AssetName, ServiceId,
	isnull(dbo.GetLookupTranslated(ServiceId,@LanguageId,'LookupValue'),'') as ServiceName, 
	isnull(dbo.CheckJobStatus(isnull(ua.StatusId,@NewStatus)),0) as IsEditable,
	Case when IsWorkNotification = 'N' then 'No' when IsWorkNotification = 'Y' then 'Yes' end IsWorkNotification  , StatusId , 
	Case when UnitType = 'DR' then 1 when UnitType = 'IN' then 2 when unitType = 'DN' then 3 end UnitOrder,
	Case when UnitType = 'DR' then (select listorder from EquipmentDriveUnit where DriveUnitId = UnitId) 
		 when UnitType = 'IN' then (select listorder from EquipmentIntermediateUnit where IntermediateUnitId = UnitId)
		 when UnitType = 'DN' then (select listorder from EquipmentDrivenUnit where DrivenUnitId = UnitId) 
		 end ListOrder,
	Case when DatavalidationStatus = 0 then dbo.GetLookupTranslated(dbo.GetStatusId(@LanguageId,'ReportStatusLegend',
	'NS'),@LanguageId,'LookupValue')
	when DatavalidationStatus = 1 then dbo.GetLookupTranslated(dbo.GetStatusId(@LanguageId,'ReportStatusLegend',
	'C'),@LanguageId,'LookupValue')
	when DatavalidationStatus = 2 then dbo.GetLookupTranslated(dbo.GetStatusId(@LanguageId,'ReportStatusLegend',
	'OD'),@LanguageId,'LookupValue')
	when DatavalidationStatus = 9 then dbo.GetLookupTranslated(dbo.GetStatusId(@LanguageId,'ReportStatusLegend',
	'NA'),@LanguageId,'LookupValue')
	end StatusColour,	 
	DatavalidationText,	
	Case when DatavalidationStatus = 2 then 'QC Failed' 
		 when DataValidationStatus = 1 then 'QC Success'
		 when DataValidationStatus = 0 then 'Not Started' 
		 when DataValidationStatus = 9 then 'Not Required'
	end DataValidationStatus, @DataCollectionDone as DataCollectionDone,
 	(select count(WNUnitAnalysisId) from WorkNotificationEquipment we join WorkNotificationUnits wu on wu.WNEquipmentId = we.WNEquipmentId and wu.StatusId = @WNOpenStatusId 
	where we.EquipmentId = @EquipmentId and we.JobId <> @JobId and wu.UnitType = ua.UnitType and wu.UnitId = ua.UnitId )OpenWorkNotifications
	from JobEquipUnitAnalysis ua where ua.JobEquipmentId = @JobEquipmentId
    order by UnitOrder,ListOrder
END

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Commit Transaction
--
IF @@TRANCOUNT>0 COMMIT TRANSACTION
GO

--
-- Set NOEXEC to off
--
SET NOEXEC OFF
GO